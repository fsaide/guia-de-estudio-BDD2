<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M贸dulo 4: SQL Procedural - Bases de Datos 2</title>
    <link rel="stylesheet" href="/static/module-style.css">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    
<div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
            <input type="checkbox" id="checkbox" />
            <div class="slider round"></div>
    </label>
</div>

<div class="container">
    <div class="page-header">
        <a href="/summary" class="btn btn-secondary">&larr;</a>
        <nav class="module-nav">
            <a href="/module1" class="nav-link">1. SQL</a>
            <a href="/module2" class="nav-link">2. Restricciones</a>
            <a href="/module3" class="nav-link">3. Vistas</a>
            <a href="/module4" class="nav-link active">4. SQL Proc.</a>
            <a href="/module5" class="nav-link">5. Optimizaci贸n</a>
            <a href="/module6" class="nav-link">6. Seguridad</a>
        </nav>
    </div>
    
    <h2>M贸dulo 4: SQL Procedural y Triggers </h2>

    <div class="module-content">
        <p>Cuando la l贸gica de negocio o las restricciones de integridad son demasiado complejas para ser expresadas mediante SQL declarativo est谩ndar (como `CHECK` o `FOREIGN KEY`), se recurre al <strong>SQL procedural</strong>. Este permite escribir bloques de c贸digo (similares a funciones en lenguajes de programaci贸n) que se almacenan y ejecutan en el servidor de base de datos.</p>
        
        <h4>Triggers (Disparadores)</h4>
        <p>Un <strong>trigger</strong> es un tipo especial de procedimiento almacenado que se ejecuta <strong>autom谩ticamente</strong> en respuesta a ciertos eventos DML (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) que ocurren en una tabla espec铆fica. Siguen el modelo <strong>Evento-Condici贸n-Acci贸n (ECA)</strong>:</p>
        <ul>
            <li><strong>Evento</strong>: La operaci贸n DML que activa el trigger (ej: `INSERT` en la tabla `Pedidos`).</li>
            <li><strong>Condici贸n</strong> (Opcional): Una expresi贸n booleana que se eval煤a antes de la acci贸n. Si es verdadera, la acci贸n se ejecuta; si es falsa, no. En PostgreSQL, esto se implementa con la cl谩usula `WHEN` en la definici贸n del trigger.</li>
            <li><strong>Acci贸n</strong>: El bloque de c贸digo SQL procedural que se ejecuta cuando el evento ocurre y la condici贸n (si existe) se cumple. En PostgreSQL, la acci贸n se define en una funci贸n separada.</li>
        </ul>

        <p><strong>Componentes Clave de un Trigger en PostgreSQL:</strong></p>
        <ul>
            <li><strong>Tiempo de activaci贸n</strong>:
                <ul>
                    <li><code>BEFORE</code>: El c贸digo se ejecuta <strong>antes</strong> de que la operaci贸n DML se aplique a la fila. Es 煤til para validar o modificar los datos que se van a insertar/actualizar. La funci贸n debe retornar la fila (<code>NEW</code>) a insertar/actualizar, o <code>NULL</code> para cancelar la operaci贸n silenciosamente.</li>
                    <li><code>AFTER</code>: El c贸digo se ejecuta <strong>despu茅s</strong> de que la operaci贸n DML se haya completado con 茅xito. til para acciones en cascada, auditor铆a o logging. La funci贸n debe retornar la fila original (<code>OLD</code> para <code>DELETE</code>, <code>NEW</code> para <code>INSERT</code>/<code>UPDATE</code>) o <code>NULL</code>.</li>
                    <li><code>INSTEAD OF</code>: Se usa <strong>solo en vistas</strong>. El c贸digo del trigger reemplaza completamente la operaci贸n DML sobre la vista, permitiendo definir manualmente c贸mo actualizar las tablas base.</li>
                </ul>
            </li>
            <li><strong>Evento</strong> : <code>INSERT</code>, <code>UPDATE [OF columna1, ...]</code>, <code>DELETE</code>, o <code>TRUNCATE</code>. Se pueden combinar m煤ltiples eventos con <code>OR</code>.</li>
            <li><strong>Granularidad</strong>:
                <ul>
                    <li><code>FOR EACH ROW</code>: El trigger se dispara una vez <strong>por cada fila</strong> afectada por la sentencia DML. Dentro de la funci贸n del trigger, se tiene acceso a las variables especiales <code>NEW</code> y <code>OLD</code>.</li>
                    <li><code>FOR EACH STATEMENT</code>: El trigger se dispara <strong>una sola vez por sentencia</strong> DML, sin importar cu谩ntas filas afecte. Las variables <code>NEW</code> y <code>OLD</code> no est谩n disponibles.</li>
                </ul>
            </li>
            <li><strong>Variables especiales (disponibles en triggers <code>FOR EACH ROW</code>)</strong>:
                <ul>
                    <li><b><code>NEW</code></b>: Un registro (tipo <code>RECORD</code>) que contiene la fila con los <strong>nuevos valores</strong> despu茅s de la operaci贸n. Disponible en <code>INSERT</code> y <code>UPDATE</code>. En un trigger <code>BEFORE</code>, se pueden modificar los valores de <code>NEW</code> antes de que se almacenen.</li>
                    <li><b><code>OLD</code></b>: Un registro que contiene la fila con los <strong>valores antiguos</strong> antes de la operaci贸n. Disponible en <code>UPDATE</code> y <code>DELETE</code>.</li>
                    <li><b><code>TG_OP</code></b>: Una variable de texto que indica la operaci贸n que dispar贸 el trigger ('INSERT', 'UPDATE', 'DELETE'). til cuando un mismo trigger maneja m煤ltiples eventos.</li>
                    <li>Otras variables como <code>TG_TABLE_NAME</code>, <code>TG_WHEN</code>, <code>TG_LEVEL</code> proporcionan metadatos sobre la ejecuci贸n del trigger.</li>
                </ul>
            </li>
        </ul>
         <p><strong>Definici贸n en PostgreSQL</strong>: Se realiza en dos pasos: 1) Crear una funci贸n que retorne el tipo <code>trigger</code> y contenga la l贸gica de la acci贸n. 2) Crear el trigger asoci谩ndolo a una tabla, evento, tiempo y granularidad, especificando qu茅 funci贸n ejecutar.</p>

        <h4>Funciones (<code>FUNCTION</code>) y Procedimientos Almacenados (<code>PROCEDURE</code>)</h4>
        <p>Son bloques de c贸digo SQL procedural (escritos en lenguajes como PL/pgSQL en PostgreSQL) que se almacenan en la base de datos y pueden ser invocados expl铆citamente.</p>
        <ul>
            <li><strong>Funciones (<code>FUNCTION</code>)</strong>:
                <ul>
                    <li>Aceptan par谩metros de entrada.</li>
                    <li><strong>Siempre devuelven un valor</strong> (un tipo simple, un registro, un conjunto de filas/tabla, etc.).</li>
                    <li>Se invocan t铆picamente dentro de una consulta <code>SELECT</code> o en expresiones.</li>
                    <li>En PostgreSQL, las acciones de los triggers se implementan obligatoriamente como funciones especiales que devuelven el tipo <code>trigger</code>.</li>
                </ul>
            </li>
            <li><strong>Procedimientos Almacenados (<code>PROCEDURE</code>)</strong>:
                <ul>
                    <li>Aceptan par谩metros de entrada, salida (<code>OUT</code>) o entrada/salida (<code>INOUT</code>).</li>
                    <li><strong>No devuelven un valor</strong> directamente como las funciones. Los resultados se obtienen a trav茅s de par谩metros <code>OUT</code>/<code>INOUT</code> o por modificaciones en las tablas.</li>
                    <li>Se invocan con el comando <code>CALL</code>.</li>
                    <li>Son adecuados para encapsular l贸gica de negocio compleja o tareas administrativas que no necesitan devolver un resultado directo.</li>
                </ul>
            </li>
        </ul>
                
        <div class="additional-info">
            <h4>Informaci贸n Adicional Clave</h4>
            <p><strong>Peligros y Consideraciones con Triggers:</strong></p>
            <ul>
                <li><strong>Cascadas de Triggers:</strong> Un trigger puede modificar datos en otra tabla, lo cual podr铆a activar otro trigger, y as铆 sucesivamente. Estas cascadas pueden volverse muy complejas de entender, depurar y mantener. Un dise帽o descuidado puede incluso llevar a recursiones infinitas si un trigger termina modificando la misma tabla que lo activ贸.</li>
                <li><strong>Rendimiento:</strong> Los triggers, especialmente los <code>FOR EACH ROW</code>, a帽aden una sobrecarga a cada operaci贸n DML. Si la l贸gica dentro del trigger es compleja o realiza consultas adicionales, puede impactar significativamente el rendimiento, sobre todo en operaciones masivas (<code>UPDATE</code>/<code>DELETE</code> que afectan miles de filas). Es crucial que el c贸digo dentro de un trigger sea lo m谩s eficiente posible.</li>
                <li><strong>Orden de Ejecuci贸n:</strong> Si existen m煤ltiples triggers para el mismo evento, tiempo y granularidad en una tabla, PostgreSQL los ejecuta en orden alfab茅tico por nombre. Esto puede ser importante si la l贸gica depende de un orden espec铆fico.</li>
                <li><strong>Transaccionalidad:</strong> Toda la operaci贸n DML original y todas las acciones realizadas por los triggers (<code>BEFORE</code> y <code>AFTER</code>) se ejecutan dentro de la misma transacci贸n. Si algo falla en cualquier punto (incluyendo un error expl铆cito como <code>RAISE EXCEPTION</code> dentro de un trigger), toda la transacci贸n se revierte (rollback).</li>
            </ul>
        </div>
        <div class="link-container">
            <a href="/module3" class="btn">&larr;</a>
            <a href="/quiz?module=4" target="_blank" class="btn">Quiz del M贸dulo 4</a>
            <a href="/practice4" target="_blank" class="btn">Practica del M贸dulo 4</a>
            <a href="/module5" class="btn">&rarr;</a>
        </div>
    </div>
</div>

<script src="/static/script.js"></script>
</body>
</html>